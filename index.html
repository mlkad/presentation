<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Micro Frontends Presentation</title>
  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/black.css">
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <section>
        <h3>Micro Frontends</h3>
        <span>A Modern Approach to Scalable Frontend Development</span>
        <aside class="notes">
          Today, I would like to introduce you to Micro Frontends — a modern solution for scaling and organizing
          frontend development.
          As applications grow in size and complexity, traditional monolithic frontend architectures start to create
          bottlenecks: long build times, difficulties with scaling teams, and risks when making even small changes.
          Micro frontends bring the idea of modularization from backend microservices into the frontend world, helping
          us to better manage complexity, enable faster development, and ensure more stable and maintainable systems.
        </aside>
      </section>

      <section>
        <h3>What are Micro Frontends?</h3>
        <ul>
          <li>An architectural style dividing frontend into independent applications.</li>
          <li>Each application is developed, tested, and deployed independently.</li>
          <li>Inspired by microservices architecture.</li>
        </ul>
        <aside class="notes">
          Micro frontends are an architectural style where a large frontend application is broken down into smaller, independent applications.
          Each micro frontend is responsible for a specific business function or feature area and is developed, tested, and deployed independently.
          Different teams can own different micro frontends and work on them autonomously, making their own decisions about technology, release schedules, and processes.
          This approach is directly inspired by microservices on the backend, where each service handles one clearly defined responsibility.
        </aside>
      </section>

      <section>
        <h3>Why Micro Frontends?</h3>
        <ul>
          <li>Manage growing complexity.</li>
          <li>Independent development and deployment.</li>
          <li>Faster updates and better fault isolation.</li>
        </ul>
        <aside class="notes">
          In traditional frontend development, as the application grows, the codebase becomes massive.
          Every small change requires navigating through a complex and interconnected system, which leads to longer development times, higher risks of breaking things, and slower deployments.
          Micro frontends address these problems by creating clear boundaries between parts of the application.
          Teams can work independently, features can be updated and deployed separately, and the overall speed and flexibility of development increase dramatically.
          Moreover, because each micro frontend is isolated, bugs or performance issues in one part of the application are less likely to impact the entire system.
        </aside>
      </section>

      <section>
        <h3>How It Works</h3>
        <ul>
          <li>Frontend is divided into business domains.</li>
          <li>Each micro frontend has its own repository and deployment.</li>
          <li>Integration happens at build-time or runtime.</li>
        </ul>
        <aside class="notes">
          To implement micro frontends, the user interface is divided into distinct sections — often based on business domains or functionalities.
          Each section is developed as a separate project, with its own repository, build process, and deployment pipeline.
          These independent applications are then integrated together to create a seamless user experience.
          Integration can happen either at build time — when all parts are compiled together — or at runtime — where different micro frontends are loaded dynamically in the browser as needed.
        </aside>
      </section>

      <section>
        <h3>Example: E-commerce Website</h3>
        <ul>
          <li>Product catalog: built with React.</li>
          <li>Shopping cart: built with Vue.js.</li>
          <li>User account: built with Angular.</li>
        </ul>
        <aside class="notes">
          For example, imagine an e-commerce platform.
          The product catalog could be a micro frontend built with React by one team.
          The shopping cart could be another micro frontend, developed using Vue.js by a different team.
          The user profile and account management section could be handled by yet another team using Angular.
          Each team can work independently, choose the best tools for their needs, and release updates without waiting for the rest of the organization.
          At the same time, for the end user, the site feels like one unified application
        </aside>
      </section>

      <section>
        <h3>Integration Approaches</h3>
        <ul>
          <li>Build-time Integration</li>
          <li>Runtime Integration</li>
        </ul>
        <aside class="notes">
          There are two main approaches to integrating micro frontends.
          The first one is build-time integration.
          In this approach, all the micro frontends are compiled and bundled together into a single application before deployment.
          This is easier to set up but reduces flexibility because every update requires rebuilding the entire system.
          
          The second approach is runtime integration, where micro frontends are loaded dynamically while the application is running.
          This allows independent deployments and updates without affecting the whole application.
          Common techniques for runtime integration include using iframes, Web Components, or solutions like Module Federation in Webpack 5 and orchestration frameworks like single-spa.
        </aside>
      </section>

      <section>
        <h3>Key Technologies</h3>
        <ul>
          <li>Webpack 5 Module Federation</li>
          <li>single-spa</li>
          <li>Web Components</li>
          <li>Qiankun framework</li>
        </ul>
        <aside class="notes">
          Several modern technologies make micro frontend architecture practical.
          Webpack 5 introduced Module Federation, which allows different applications to share code and load components from one another at runtime.
          single-spa is a framework designed specifically for orchestrating multiple micro frontends running together on the same page.
          Web Components offer a standardized way to create reusable, encapsulated components that can work across different frontend frameworks.
          Another powerful tool is Qiankun, built on top of single-spa, which simplifies runtime loading, sandboxing, and communication between micro frontends.
        </aside>
      </section>

      <section>
        <h3>Module Federation Example</h3>
        <pre><code class="hljs javascript">
const RemoteButton = React.lazy(() => import('app2/Button'));
        </code></pre>
        <aside class="notes">
          Let's briefly look at an example of how Module Federation works.
          Imagine you have a main application, and you want to load a button component from another application dynamically.
          In React, this would look like:
          
          const RemoteButton = React.lazy(() => import('app2/Button'));
          This way, the button component from the remote app2 is loaded only when it is needed, without having to rebuild the main application.
          This makes the system much more modular and flexible.
        </aside>
      </section>

      <section>
        <h3>Advantages</h3>
        <ul>
          <li>Team independence</li>
          <li>Faster deployments</li>
          <li>Technological freedom</li>
          <li>Fault isolation</li>
        </ul>
        <aside class="notes">
          The benefits of micro frontends are significant.
          First, teams gain true independence: they can develop, test, and deploy their features without waiting for others.
          Second, release cycles become much faster because smaller, isolated changes can be pushed without fear of breaking unrelated parts.
          Third, different teams can choose the technologies and tools that best fit their needs, which fosters innovation.
          Finally, micro frontends offer better fault isolation: if a particular micro frontend fails, the rest of the application remains functional, improving overall reliability.
        </aside>
      </section>

      <section>
        <h3>Challenges</h3>
        <ul>
          <li>Infrastructure complexity</li>
          <li>Performance optimization needed</li>
          <li>Consistency across micro frontends</li>
        </ul>
        <aside class="notes">
          However, adopting micro frontends is not without challenges.
          Managing multiple applications introduces complexity in the infrastructure: more repositories, more CI/CD pipelines, and more deployment environments.
          Performance must be carefully monitored — if each micro frontend ships its own version of common libraries like React, bundle sizes can grow uncontrollably.
          Maintaining a consistent design and user experience across independently developed micro frontends also requires extra effort, usually through shared design systems and strict guidelines.
          Architectural discipline, clear boundaries, and strong communication across teams are absolutely essential for success.
        </aside>
      </section>

      <section>
        <h3>When to Use Micro Frontends?</h3>
        <ul>
          <li>Large, complex projects</li>
          <li>Multiple independent teams</li>
          <li>Frequent independent releases needed</li>
        </ul>
        <aside class="notes">
          Micro frontends are an excellent solution for large-scale, enterprise-level applications with many independent teams working on different features.
          They are particularly useful when parts of an application need to evolve at different speeds, or when frequent independent deployments are required.
          However, for smaller or less complex projects, the overhead and complexity of micro frontend architecture often outweigh the benefits.
          Choosing to adopt micro frontends should always be a strategic decision based on project size, team structure, and long-term goals.
        </aside>
      </section>

      <section>
        <h3>Conclusion</h3>
        <span>Micro frontends bring modularity, autonomy, and scalability to frontend development.</span>
        <aside class="notes">
          In conclusion, micro frontends represent a powerful evolution in frontend architecture, bringing modularity, autonomy, and scalability to frontend development.
          They allow organizations to build more resilient and flexible applications, respond faster to market demands, and scale teams more effectively.
          However, micro frontends also demand careful planning, strong collaboration, and a clear architectural vision to avoid introducing unnecessary complexity.
          When applied thoughtfully, micro frontends can significantly enhance the maintainability, scalability, and success of large frontend projects.
        </aside>
      </section>

    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>